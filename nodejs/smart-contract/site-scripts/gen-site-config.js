#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const dotenv = require("dotenv");

const smartContractRoot = path.resolve(__dirname, "..");
const repoRoot = path.resolve(smartContractRoot, "..", "..");
const outputPath = path.join(repoRoot, "assets/web3/config/runtime.generated.js");
const contractsDir = path.join(smartContractRoot, "contracts-deployed");

dotenv.config({ path: path.join(smartContractRoot, ".env.site") });

const env = process.env;

function parseBool(value, fallback = false) {
  if (typeof value === "boolean") return value;
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (["1", "true", "yes", "on"].includes(normalized)) return true;
    if (["0", "false", "no", "off"].includes(normalized)) return false;
  }
  return fallback;
}

function parseIntish(value, fallback) {
  if (typeof value === "number" && Number.isFinite(value)) return Math.trunc(value);
  if (typeof value === "string" && value.trim() !== "") {
    const parsed = Number.parseInt(value, 10);
    if (Number.isFinite(parsed)) return parsed;
  }
  return fallback;
}

function parseFloatish(value, fallback) {
  if (typeof value === "number" && Number.isFinite(value)) return value;
  if (typeof value === "string" && value.trim() !== "") {
    const parsed = Number.parseFloat(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return fallback;
}

function readAddress(contract, network) {
  const file = path.join(contractsDir, `${contract}-${network}.json`);
  if (!fs.existsSync(file)) return null;
  try {
    const parsed = JSON.parse(fs.readFileSync(file, "utf8"));
    return parsed?.address || null;
  } catch (error) {
    console.warn(`Failed to parse ${file}:`, error.message);
    return null;
  }
}

function collectAddresses(network) {
  const upper = network.toUpperCase();
  const fromEnvPrimary = env[`${upper}_PRIMARY_ADDRESS`];
  const fromEnvUnderlay = env[`${upper}_UNDERLAY_ADDRESS`];
  const fromJsonPrimary = readAddress("primary", network);
  const fromJsonUnderlay = readAddress("underlay", network);
  return {
    primary: fromEnvPrimary || fromJsonPrimary || null,
    underlay: fromEnvUnderlay || fromJsonUnderlay || null,
  };
}

function collectAssetBases() {
  return {
    mainnet: env.ASSET_BASE_MAINNET || "/build",
    sepolia: env.ASSET_BASE_SEPOLIA || "/build-sepolia",
    sunet: env.ASSET_BASE_SUNET || "/build-sunet",
  };
}

function pruneUndefined(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([, value]) => value !== undefined && value !== null && value !== "")
  );
}

function main() {
  const chain = (env.CHAIN || "mainnet").toLowerCase();
  const allowedChains = ["mainnet", "sepolia", "sunet"];
  if (!allowedChains.includes(chain)) {
    throw new Error(`Invalid CHAIN value: ${chain}. Expected one of ${allowedChains.join(", ")}`);
  }

  const addresses = {
    mainnet: collectAddresses("mainnet"),
    sepolia: collectAddresses("sepolia"),
    sunet: collectAddresses("sunet"),
  };
  const assetBases = collectAssetBases();

  if (chain !== "mainnet") {
    const { primary, underlay } = addresses[chain] || {};
    if (!primary || !underlay) {
      throw new Error(
        `Missing contract addresses for ${chain}. Set ${chain.toUpperCase()}_PRIMARY_ADDRESS and ${chain.toUpperCase()}_UNDERLAY_ADDRESS or provide contracts-deployed/*-${chain}.json`
      );
    }
  }

  const sunetChainId = parseIntish(env.SUNET_CHAIN_ID, 99999991);
  const mintPriceEth = parseFloatish(env.MINT_PRICE_ETH, 0.5);
  const personalizePriceEth = parseFloatish(env.PERSONALIZE_PRICE_ETH, 0.001);
  const configPayload = pruneUndefined({
    chain,
    debug: parseBool(env.DEBUG, false),
    walletConnectProjectId: env.WALLETCONNECT_PROJECT_ID,
    mainnetPrimaryAddress: addresses.mainnet.primary,
    mainnetUnderlayAddress: addresses.mainnet.underlay,
    sepoliaPrimaryAddress: addresses.sepolia.primary,
    sepoliaUnderlayAddress: addresses.sepolia.underlay,
    sunetPrimaryAddress: addresses.sunet.primary,
    sunetUnderlayAddress: addresses.sunet.underlay,
    sunetChainId,
    sunetBlockExplorerUrl: env.SUNET_BLOCK_EXPLORER_URL || "http://192.168.1.40:4001",
    sunetRpcUrl: env.SUNET_RPC_URL || "http://192.168.1.40:8545",
    assetBases,
    pricing: {
      mintPriceEth,
      personalizePriceEth,
    },
  });

  const banner = "// Auto-generated by nodejs/smart-contract/site-scripts/gen-site-config.js. Do not edit by hand.\n";
  const contents = `${banner}window.suWeb3 = Object.assign({}, window.suWeb3, ${JSON.stringify(
    configPayload,
    null,
    2
  )});\n`;

  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, contents, "utf8");
  console.log(`Wrote runtime config to ${path.relative(repoRoot, outputPath)}`);
}

try {
  main();
} catch (error) {
  console.error("Failed to generate site runtime config:", error.message);
  process.exit(1);
}
